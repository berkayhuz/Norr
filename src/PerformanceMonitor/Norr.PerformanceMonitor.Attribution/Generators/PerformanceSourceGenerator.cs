using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Norr.PerformanceMonitor.Attribution.Generators;

/// <summary>
/// A source generator that looks for methods marked with the <see cref="MeasurePerformanceAttribute"/>
/// and generates a partial method with performance monitoring logic around it.  
/// The generated method will wrap the original method call in a performance monitoring scope, which records
/// the execution time, memory allocations, and CPU usage.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class PerformanceSourceGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext ctx)
    {
        // Find methods with [MeasurePerformance] attribute
        var methods = ctx.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (node, _) => node is MethodDeclarationSyntax m && m.AttributeLists.Count > 0,
            transform: static (ic, _) =>
            {
                var mDecl = (MethodDeclarationSyntax)ic.Node;
                var model = ic.SemanticModel;
                var symbol = model.GetDeclaredSymbol(mDecl) as IMethodSymbol;
                return (mDecl, symbol);
            })
            .Where(p => p.symbol is not null &&
                        p.symbol!.GetAttributes()
                            .Any(a => a.AttributeClass?.ToDisplayString() == "PerformanceMonitoring.MeasurePerformanceAttribute"));

        // Generate source
        ctx.RegisterSourceOutput(methods, static (spc, pair) =>
        {
            var (_, method) = pair;
            if (method is null)
                return;

            // Extract method details
            var ns = method.ContainingNamespace.ToDisplayString();
            var cls = method.ContainingType.Name;
            var name = method.Name;
            var ret = method.ReturnType.ToDisplayString();

            // Prepare method signature
            var paramList = string.Join(", ", method.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}"));
            var proxySig = paramList.Length == 0
                ? "(IPerformanceMonitor monitor)"
                : $"({paramList}, IPerformanceMonitor monitor)";

            var invokeArgs = string.Join(", ", method.Parameters.Select(p => p.Name));

            // Generate source code
            var src = $$"""
            // <auto-generated/>
            using Norr.PerformanceMonitoring;
            namespace {{ns}};
            partial class {{cls}}
            {
                public partial {{ret}} {{name}}_WithPerf{{proxySig}}
                {
                    using var _ = monitor.Begin("{{cls}}.{{name}}");
                    {{(ret == "void" ? "" : "return ")}}{{name}}({{invokeArgs}});
                }
            }
            """;  // Ensure that the template string is properly closed

            // Output the generated source file
            spc.AddSource($"{cls}_{name}_Perf.g.cs", SourceText.From(src, Encoding.UTF8));
        });
    }
}
